{"version":3,"sources":["monitoring/stats-agent/compute-metric.ts","monitoring/stats-agent/index.ts","monitoring/ReactProfilerProd.tsx","App.tsx","monitoring/long-task-observer.ts","serviceWorker.ts","index.tsx"],"names":["getPercentile","sortedMetrics","percentile","length","value","rank","integer","Math","floor","rankFraction","element","nextElement","buffer","actionsQueue","name","timestamp","Date","now","internalMetricsAgent","start","window","addEventListener","flushMetrics","groupByContext","metricsEvents","contextMap","forEach","metric","context","undefined","metricContext","Object","keys","map","key","join","metricId","metricName","metricType","push","getTagsInLogsFormat","tags","keyValues","tag","splitTag","split","slice","tagMap","keyValue","sendContext","action","contextKey","log","metrics","contextMetadata","index","computeMetric","actionContextString","actionContext","datadogLogs","logger","info","performanceEntryType","computeCount","reduce","currentCount","computeGauge","parseInt","computeSet","Set","size","computeHistogram","sort","a","b","avg","sum","median","max","min","p95","shift","bufferToSend","agent","onRenderChildren","id","phase","actualDuration","console","duration","react","component","ReactProfilerProd","children","onRender","AddBar","addTodo","useState","todoName","setTodoName","onChange","e","target","onKeyPress","placeholder","className","TodoLine","slow","App","useEffect","startLongTaskObserver","PerformanceObserver","list","perfEntries","getEntries","i","longtask","entryType","startTime","observe","entryTypes","todoList","setTodoList","total_todos","Boolean","location","hostname","match","init","clientToken","datacenter","isCollectingError","sampleRate","addLoggerGlobalContext","_DATADOG_SYNTHETICS_BROWSER","ReactDOM","render","StrictMode","document","getElementById","unregister","navigator","serviceWorker","ready","then","registration","catch","error","message"],"mappings":"oSAwBMA,EAAgB,SAAhBA,cAAiBC,EAAyBC,GAC5C,GAA6B,IAAzBD,EAAcE,OACd,OAAOF,EAAc,GAAGG,MAE5B,IAAMC,EAAQH,EAAa,KAAQD,EAAcE,OAAS,GACpDG,EAAUC,KAAKC,MAAMH,GACrBI,EAAeJ,EAAOC,EACtBI,EAAUT,EAAcK,GACxBK,EAAcV,EAAcK,EAAU,GAC5C,OACKI,EAAQN,MACTK,GACME,EAAYP,MAAoBM,EAAQN,QCAlDQ,EAAmB,GAMjBC,EAA6B,CAAC,CAAEC,KAAM,YAAaC,UAAWC,KAAKC,QAwHnEC,EAAuB,I,uEArH3BC,MAAQ,WACNC,OAAOC,iBAAiB,gBAAgB,WACtC,EAAKC,mB,KAGTC,eAAiB,SAACC,GAChB,IAAMC,EAAyB,GAkB/B,OAjBAD,EAAcE,SAAQ,SAACC,GACrB,IAAIC,EAAU,aACd,QAAuBC,IAAnBF,EAAOC,QAAuB,CAChC,IAAME,EAAgBH,EAAOC,QAC7BA,EAAUG,OAAOC,KAAKL,EAAOC,SAC1BK,KAAI,SAACC,GAAD,gBAAYA,EAAZ,YAAmBJ,EAAcI,OACrCC,KAAK,KAELV,EAAWG,KACdH,EAAWG,GAAW,IAExB,IAAMQ,EAAQ,UAAMT,EAAOU,WAAb,YAA2BV,EAAOW,YAC3Cb,EAAWG,GAASQ,KACvBX,EAAWG,GAASQ,GAAY,IAElCX,EAAWG,GAASQ,GAAUG,KAAKZ,MAE9BF,G,KAGTe,oBAAsB,SAACC,GACrB,IAAMC,EAAYD,EAAKR,KAAI,SAACU,GAC1B,IAAMC,EAAWD,EAAIE,MAAM,KAC3B,MAAO,CACLX,IAAKU,EAAS,GACdxC,MAAOwC,EAASE,MAAM,GAAGX,KAAK,SAG5BY,EAAiB,GAIvB,OAHAL,EAAUhB,SAAQ,SAACsB,GACjBD,EAAOC,EAASd,KAAOc,EAAS5C,SAE3B2C,G,KAGTE,YAAc,SACZC,EACAC,EACAvB,GAEA,IAAMwB,EAAqB,CACzBrC,UAAWmC,EAAOnC,UAClBsC,QAAS,IAGPC,EAEA,GACAjB,EAAa,UAEjBN,OAAOC,KAAKJ,GAASF,SAAQ,SAACU,EAAUmB,GAExB,IAAVA,IACFD,EAAkB1B,EAAQQ,GAAU,GAAGR,SAAW,GAClDS,EAAaT,EAAQQ,GAAU,GAAGC,YAEpC,EAAKmB,cAAcJ,EAAKhB,EAAUR,EAAQQ,OAE5C,IAAMqB,EAAsBP,EAAOQ,cAC/B3B,OAAOC,KAAKkB,EAAOQ,eAChBzB,KAAI,SAACC,GAAD,gBAAoBA,EAApB,YAA4BgB,EAAOQ,cAAsBxB,OAC7DC,KAAK,KACR,GACJwB,IAAYC,OAAOC,KAAnB,kBACaX,EAAOpC,KADpB,YAC4B2C,EAD5B,qBAC4D1B,OAAOC,KAC/DJ,GACAO,KAAK,KAHT,qBAG0BgB,GAH1B,aAKID,OAAQA,EAAOpC,KACfa,OAAQU,EACRqB,cAAeR,EAAOQ,cACtBI,qBAAsB,cACtB/C,UAAWqC,EAAIrC,UACfsC,QAASD,EAAIC,SACVC,K,KAKTE,cAAgB,SAACJ,EAAoBhB,EAAkBiB,GAErD,OADmBA,EAAQ,GAAGf,YAE5B,IAAK,QACHc,EAAIC,QAAQjB,GDrIQ,SAAf2B,aAAgBV,GACzB,OAAOA,EAAQW,QACX,SAACC,EAAsBtC,GAAvB,OACIsC,EAAgBtC,EAAOvB,QAC3B,GCiIwB2D,CAAaV,GACrC,MACF,IAAK,QACHD,EAAIC,QAAQjB,GDhIQ,SAAf8B,aAAgBb,GACzB,OAAOA,EAAQW,QAAO,SAACC,EAAsBtC,GACzC,MAA4B,kBAAjBA,EAAOvB,MACP6D,EAAeE,SAASxC,EAAOvB,MAAO,IAE1CuB,EAAOvB,QACf,GC0HyB8D,CAAab,GACrC,MACF,IAAK,MACHD,EAAIC,QAAQjB,GD1HM,SAAbgC,WAAcf,GAEvB,OADY,IAAIgB,IAAIhB,EAAQpB,KAAI,SAAAN,GAAM,OAAIA,EAAOvB,UACtCkE,KCwHiBF,CAAWf,GACnC,MACF,IAAK,YACL,IAAK,SACHD,EAAIC,QAAQjB,GDzGY,SAAnBmC,iBAAoBlB,GAC7B,IAAMpD,EAAgBoD,EAAQmB,MAAK,SAACC,EAAGC,GACnC,OAAQD,EAAErE,MAAoBsE,EAAEtE,SAGpC,MAAO,CACHuE,IACI1E,EAAc+D,QACV,SAACY,EAAKjD,GAAN,OAAiBiD,EAAOjD,EAAOvB,QAC/B,GACAH,EAAcE,OACtB0E,OAAQ7E,EAAcC,EAAe,IACrC6E,IAAK7E,EAAcA,EAAcE,OAAS,GAAGC,MAC7C2E,IAAK9E,EAAc,GAAGG,MACtB4E,IAAKhF,EAAcC,EAAe,KC2FVsE,CAAiBlB,K,KAO/C/B,aAAe,WACb,IAAM4B,EAASrC,EAAaoE,QACtBC,EAAY,YAAOtE,GACzBA,EAAS,GACT,IAAMa,EAAa,EAAKF,eAAe2D,GACvCnD,OAAOC,KAAKP,GAAYC,SAAQ,SAACyB,GAC/B,EAAKF,YAAYC,EAAQC,EAAY1B,EAAW0B,SAKtDjC,EAAqBC,QAEd,IAAMgE,EAEK,wBAACxD,GACff,EAAO2B,KAAKZ,IAHHwD,EAKK,wBACdrE,EACA4C,GAGAxC,EAAqBI,eAErBT,EAAa0B,KAAK,CAAEzB,OAAM4C,cAAeA,EAAe3C,UAAWC,KAAKC,SClKtEmE,EAA6C,SAA7CA,iBACJC,EACAC,EACAC,GAGAC,QAAQpC,IAAIiC,EAAIC,EAAOC,GAEvB5B,IAAYC,OAAOC,KAAnB,qCACgCwB,EADhC,yBACmDE,EADnD,eACwED,GACtE,CACExB,qBAAsB,gBACtB2B,SAAUF,EACVG,MAAO,CACLC,UAAWN,EACXC,WAONH,EAAqB,CACnB9C,WAzBwB,eA0BxBC,WAAY,QACZlC,MAAO,EACPwB,QAAS,CACP,WAAYyD,EACZ,cAAeC,KAInBH,EAAqB,CACnB9C,WAnCwB,eAoCxBC,WAAY,SACZlC,MAAOmF,EACP3D,QAAS,CACP,WAAYyD,EACZ,cAAeC,MAKRM,EAAoB,SAApBA,kBAAqB,GAAqC,IAAnCP,EAAkC,EAAlCA,GAAIQ,EAA8B,EAA9BA,SACtC,OACE,kBAAC,WAAD,CAAeR,GAAIA,EAAIS,SAAUV,GAC9BS,ICzDP,SAASE,OAAT,GAAmE,IAAjDC,EAAgD,EAAhDA,QAAgD,EAChCC,mBAAS,IADuB,mBACzDC,EADyD,KAC/CC,EAD+C,KAEhE,OACE,2BACE/F,MAAO8F,EACPE,SAAU,kBAACC,GAAD,OAAOF,EAAYE,EAAEC,OAAOlG,QACtCmG,WAAY,oBAACF,GACG,UAAVA,EAAEnE,MACJ8D,EAAQE,GACRC,EAAY,MAGhBK,YAAY,WACZC,UAAU,uEAKhB,SAASC,SAAT,GAEE,IAF6C,IAA3B5F,EAA0B,EAA1BA,KACZ6F,EAAO3F,KAAKC,MAAQ,GACnBD,KAAKC,MAAQ0F,IACpB,OACE,wBAAIF,UAAU,2DACX3F,GAoCQ8F,MA/Bf,SAASA,MACPC,qBAAU,YC5ByB,SAAxBC,wBACI,IAAIC,qBAAoB,SAAUC,GAE/C,IADA,IAAIC,EAAcD,EAAKE,aACdC,EAAI,EAAGA,EAAIF,EAAY9G,OAAQgH,IAAK,CAC3C,IAAMC,EAAWH,EAAYE,GAE7B3B,QAAQpC,IAAIgE,GAEe,aAAvBA,EAASC,WACX1D,IAAYC,OAAOC,KAAK,oBAAqB,CAC3C4B,SAAU2B,EAAS3B,SACnB3B,qBAAsBsD,EAASC,UAC/BC,UAAWF,EAASE,YAKxBnC,EAAqB,CACnB9C,WApBiB,YAqBjBC,WAAY,QACZlC,MAAO,IAGT+E,EAAqB,CACnB9C,WA1BiB,YA2BjBC,WAAY,SACZlC,MAAOgH,EAAS3B,eAKb8B,QAAQ,CAAEC,WAAY,CAAC,cDF9BV,KACC,IAHU,MAImBb,mBAAmB,IAJtC,mBAINwB,EAJM,KAIIC,EAJJ,KAKb,OACE,yBAAKjB,UAAU,gCACb,yBAAKA,UAAU,2BACb,wBAAIA,UAAU,sBAAd,YACA,kBAACV,OAAD,CACEC,QAAS,iBAAClF,GACR4G,EAAY,GAAD,mBAAKD,GAAL,CAAe3G,KAC1BqE,EAAqB,WAAY,CAC/BwC,YAAaF,EAAStH,OAAS,OAIrC,kBAAC,EAAD,CAAmBkF,GAAG,YACpB,4BACGoC,EAASxF,KAAI,SAACnB,EAAMyC,GAAP,OACZ,kBAAC,EAAD,CAAmBrB,IAAKqB,EAAO8B,GAAG,YAChC,kBAACqB,SAAD,CAAU5F,KAAMA,aEzCZ8G,QACW,cAA7BxG,OAAOyG,SAASC,UAEe,UAA7B1G,OAAOyG,SAASC,UAEhB1G,OAAOyG,SAASC,SAASC,MACvB,2DCXNpE,IAAYqE,KAAK,CACfC,YAAa,sCACbC,WAAY,KACZC,mBAAmB,EACnBC,WAAY,MAOdzE,IAAY0E,uBACV,aACsC,MAAtCjH,OAAOkH,6BAGT3E,IAAYC,OAAOC,KAAK,oDAExB0E,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SD6GnB,SAASC,aACV,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaL,gBAEdM,OAAM,SAAAC,GACL3D,QAAQ2D,MAAMA,EAAMC,YC9G5BN,K","file":"static/js/main.ceffd9a7.chunk.js","sourcesContent":["import { Metric } from './metric';\n\nexport const computeCount = (metrics: Metric[]): number => {\n    return metrics.reduce(\n        (currentCount: number, metric) =>\n            currentCount + (metric.value as number),\n        0\n    );\n};\n\nexport const computeGauge = (metrics: Metric[]): number => {\n    return metrics.reduce((currentCount: number, metric) => {\n        if (typeof metric.value === 'string') {\n            return currentCount + parseInt(metric.value, 10);\n        }\n        return metric.value;\n    }, 0);\n};\n\nexport const computeSet = (metrics: Metric[]): number => {\n    const set = new Set(metrics.map(metric => metric.value));\n    return set.size;\n};\n\nconst getPercentile = (sortedMetrics: Metric[], percentile: number): number => {\n    if (sortedMetrics.length === 1) {\n        return sortedMetrics[0].value as number;\n    }\n    const rank = (percentile / 100) * (sortedMetrics.length - 1);\n    const integer = Math.floor(rank);\n    const rankFraction = rank - integer;\n    const element = sortedMetrics[integer];\n    const nextElement = sortedMetrics[integer + 1];\n    return (\n        (element.value as number) +\n        rankFraction *\n            ((nextElement.value as number) - (element.value as number))\n    );\n};\n\nexport const computeHistogram = (metrics: Metric[]) => {\n    const sortedMetrics = metrics.sort((a, b) => {\n        return (a.value as number) - (b.value as number);\n    });\n\n    return {\n        avg:\n            sortedMetrics.reduce(\n                (sum, metric) => sum + (metric.value as number),\n                0\n            ) / sortedMetrics.length,\n        median: getPercentile(sortedMetrics, 50),\n        max: sortedMetrics[sortedMetrics.length - 1].value as number,\n        min: sortedMetrics[0].value as number,\n        p95: getPercentile(sortedMetrics, 95)\n    };\n};","import { Metric } from \"./metric\";\nimport {\n  computeCount,\n  computeGauge,\n  computeSet,\n  computeHistogram,\n} from \"./compute-metric\";\nimport { datadogLogs } from \"@datadog/browser-logs\";\n\ninterface MetricContext {\n  [metricId: string]: Metric[];\n}\n\ninterface TagMap {\n  [tag: string]: string;\n}\n\ninterface ContextMap {\n  [context: string]: MetricContext;\n}\n\ninterface Histogram {\n  avg: number;\n  median: number;\n  max: number;\n  min: number;\n  p95: number;\n}\n\ninterface MetricMessage {\n  timestamp: number;\n  metrics: {\n    [metricName: string]: number | Histogram;\n  };\n}\n\nlet buffer: Metric[] = [];\ninterface UserAction {\n  name: string;\n  timestamp: number;\n  actionContext?: { [key: string]: string | number };\n}\nconst actionsQueue: UserAction[] = [{ name: \"PAGE_LOAD\", timestamp: Date.now() }];\n\nclass MetricsAgent {\n  start = () => {\n    window.addEventListener(\"beforeunload\", () => {\n      this.flushMetrics();\n    });\n  };\n  groupByContext = (metricsEvents: Metric[]) => {\n    const contextMap: ContextMap = {};\n    metricsEvents.forEach((metric) => {\n      let context = \"no-context\";\n      if (metric.context !== undefined) {\n        const metricContext = metric.context as { [key: string]: string };\n        context = Object.keys(metric.context)\n          .map((key) => `${key}:${metricContext[key]}`)\n          .join(\"|\");\n      }\n      if (!contextMap[context]) {\n        contextMap[context] = {};\n      }\n      const metricId = `${metric.metricName}.${metric.metricType}`;\n      if (!contextMap[context][metricId]) {\n        contextMap[context][metricId] = [];\n      }\n      contextMap[context][metricId].push(metric);\n    });\n    return contextMap;\n  };\n\n  getTagsInLogsFormat = (tags: string[]) => {\n    const keyValues = tags.map((tag) => {\n      const splitTag = tag.split(\":\");\n      return {\n        key: splitTag[0],\n        value: splitTag.slice(1).join(\":\"),\n      };\n    });\n    const tagMap: TagMap = {};\n    keyValues.forEach((keyValue) => {\n      tagMap[keyValue.key] = keyValue.value;\n    });\n    return tagMap;\n  };\n\n  sendContext = (\n    action: UserAction,\n    contextKey: string,\n    context: MetricContext\n  ) => {\n    const log: MetricMessage = {\n      timestamp: action.timestamp,\n      metrics: {},\n    };\n\n    let contextMetadata: {\n      [key: string]: string;\n    } = {};\n    let metricName = 'unknown';\n\n    Object.keys(context).forEach((metricId, index) => {\n      // should all be the same as we grouped by this before\n      if (index === 0) {\n        contextMetadata = context[metricId][0].context || {};\n        metricName = context[metricId][0].metricName;\n      }\n      this.computeMetric(log, metricId, context[metricId]);\n    });\n    const actionContextString = action.actionContext\n      ? Object.keys(action.actionContext)\n          .map((key: string) => `${key}:${(action.actionContext as any)[key]}`)\n          .join(\"|\")\n      : \"\";\n    datadogLogs.logger.info(\n      `ACTION: ${action.name} ${actionContextString} METRICS: ${Object.keys(\n        context\n      ).join(\"|\")} CONTEXT: ${contextKey}`,\n      {\n        action: action.name,\n        metric: metricName,\n        actionContext: action.actionContext,\n        performanceEntryType: \"stats-agent\",\n        timestamp: log.timestamp,\n        metrics: log.metrics as any,\n        ...contextMetadata,\n      }\n    );\n  };\n\n  computeMetric = (log: MetricMessage, metricId: string, metrics: Metric[]) => {\n    const metricType = metrics[0].metricType;\n    switch (metricType) {\n      case \"count\":\n        log.metrics[metricId] = computeCount(metrics);\n        break;\n      case \"gauge\":\n        log.metrics[metricId] = computeGauge(metrics);\n        break;\n      case \"set\":\n        log.metrics[metricId] = computeSet(metrics);\n        break;\n      case \"histogram\":\n      case \"timing\":\n        log.metrics[metricId] = computeHistogram(metrics);\n        break;\n      default:\n        break;\n    }\n  };\n\n  flushMetrics = () => {\n    const action = actionsQueue.shift() as UserAction;\n    const bufferToSend = [...buffer];\n    buffer = [];\n    const contextMap = this.groupByContext(bufferToSend);\n    Object.keys(contextMap).forEach((contextKey) => {\n      this.sendContext(action, contextKey, contextMap[contextKey]);\n    });\n  };\n}\nconst internalMetricsAgent = new MetricsAgent();\ninternalMetricsAgent.start();\n\nexport const agent = {\n  // register metric\n  addMetricPoint: (metric: Metric) => {\n    buffer.push(metric);\n  },\n  markUserAction: (\n    name: UserAction[\"name\"],\n    actionContext?: UserAction[\"actionContext\"]\n  ) => {\n    // flush metrics to link them to the previous action that triggered them\n    internalMetricsAgent.flushMetrics();\n    // add new action to the queue to be the next one flushed\n    actionsQueue.push({ name, actionContext: actionContext, timestamp: Date.now() });\n  },\n};\n","import React, {\n  Profiler as ReactProfiler,\n  ProfilerProps as ReactProfilerProps,\n  ProfilerOnRenderCallback,\n  ReactNode,\n} from \"react\";\nimport { datadogLogs } from \"@datadog/browser-logs\";\nimport { agent } from \"./stats-agent\";\ninterface ProfilerProps {\n  id: ReactProfilerProps[\"id\"];\n  children: ReactNode;\n}\n\nconst REACT_RENDER_METRIC = \"react_render\";\n\nconst onRenderChildren: ProfilerOnRenderCallback = (\n  id,\n  phase,\n  actualDuration\n) => {\n  // local logging\n  console.log(id, phase, actualDuration);\n  // render logs to log management\n  datadogLogs.logger.info(\n    `react profiler - component ${id} rendered for ${actualDuration} on ${phase}`,\n    {\n      performanceEntryType: \"reactprofiler\",\n      duration: actualDuration,\n      react: {\n        component: id,\n        phase,\n      },\n    }\n  );\n\n  // aggregate with user actions before sending\n  // count number of renders\n  agent.addMetricPoint({\n    metricName: REACT_RENDER_METRIC,\n    metricType: \"count\",\n    value: 1,\n    context: {\n      'react.id': id, // identify the component\n      'react.phase': phase, // update vs mount\n    },\n  });\n  // compute p99 avg... render timings\n  agent.addMetricPoint({\n    metricName: REACT_RENDER_METRIC,\n    metricType: \"timing\",\n    value: actualDuration,\n    context: {\n      'react.id': id, // identify the component\n      'react.phase': phase, // update vs mount\n    },\n  });\n};\n\nexport const ReactProfilerProd = ({ id, children }: ProfilerProps) => {\n  return (\n    <ReactProfiler id={id} onRender={onRenderChildren}>\n      {children}\n    </ReactProfiler>\n  );\n};\n","import React, { useState, useEffect } from \"react\";\nimport { ReactProfilerProd } from \"./monitoring/ReactProfilerProd\";\nimport { startLongTaskObserver } from \"./monitoring/long-task-observer\";\nimport { agent } from \"./monitoring/stats-agent\";\nfunction AddBar({ addTodo }: { addTodo: (name: string) => void }) {\n  const [todoName, setTodoName] = useState(\"\");\n  return (\n    <input\n      value={todoName}\n      onChange={(e) => setTodoName(e.target.value)}\n      onKeyPress={(e) => {\n        if (e.key === \"Enter\") {\n          addTodo(todoName);\n          setTodoName(\"\");\n        }\n      }}\n      placeholder=\"add todo\"\n      className=\"w-full appearance-none border border-gray-300 rounded-lg py-2 px-4\"\n    />\n  );\n}\n\nfunction TodoLine({ name }: { name: string }) {\n  const slow = Date.now() + 25;\n  while (Date.now() < slow) {}\n  return (\n    <li className=\"w-full border border-gray-500 rounded-lg py-2 px-4 mt-2\">\n      {name}\n    </li>\n  );\n}\n\nfunction App() {\n  useEffect(() => {\n    startLongTaskObserver();\n  }, []);\n  const [todoList, setTodoList] = useState<string[]>([]);\n  return (\n    <div className=\"flex flex-row justify-center\">\n      <div className=\"container flex flex-col\">\n        <h1 className=\"underline text-red\">TODOLIST</h1>\n        <AddBar\n          addTodo={(name: string) => {\n            setTodoList([...todoList, name]);\n            agent.markUserAction(\"add_todo\", {\n              total_todos: todoList.length + 1,\n            });\n          }}\n        />\n        <ReactProfilerProd id=\"TodoList\">\n          <ul>\n            {todoList.map((name, index) => (\n              <ReactProfilerProd key={index} id=\"TodoLine\">\n                <TodoLine name={name} />\n              </ReactProfilerProd>\n            ))}\n          </ul>\n        </ReactProfilerProd>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { datadogLogs } from \"@datadog/browser-logs\";\nimport { agent } from \"./stats-agent\";\n\nconst LONG_TASK_METRIC = \"long_task\";\n\nexport const startLongTaskObserver = () => {\n  var observer = new PerformanceObserver(function (list) {\n    var perfEntries = list.getEntries();\n    for (var i = 0; i < perfEntries.length; i++) {\n      const longtask = perfEntries[i];\n      //  local log\n      console.log(longtask);\n      // send to log management app\n      if (longtask.entryType === \"longtask\") {\n        datadogLogs.logger.info(\"longtask detected\", {\n          duration: longtask.duration,\n          performanceEntryType: longtask.entryType,\n          startTime: longtask.startTime,\n        });\n      }\n      // compute aggregated timings for longtasks\n      // number of long tasks\n      agent.addMetricPoint({\n        metricName: LONG_TASK_METRIC,\n        metricType: \"count\",\n        value: 1,\n      });\n      // compute p99 avg... \n      agent.addMetricPoint({\n        metricName: LONG_TASK_METRIC,\n        metricType: \"timing\",\n        value: longtask.duration,\n      });\n    }\n  });\n  // register observer for long task notifications\n  observer.observe({ entryTypes: [\"longtask\"] });\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { datadogLogs } from \"@datadog/browser-logs\";\n\ndatadogLogs.init({\n  clientToken: \"pubf7c8eec264a69c5aa69ad6fec1bb36b7\",\n  datacenter: \"us\",\n  isCollectingError: true,\n  sampleRate: 100,\n});\ndeclare global {\n  interface Window {\n    _DATADOG_SYNTHETICS_BROWSER: any;\n  }\n}\ndatadogLogs.addLoggerGlobalContext(\n  \"is_a_robot\",\n  window._DATADOG_SYNTHETICS_BROWSER != null\n);\n\ndatadogLogs.logger.info(\"Javascript loaded - React Performance Monitoring\");\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}